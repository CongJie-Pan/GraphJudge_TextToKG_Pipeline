<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŸ¥è­˜åœ–è­œå¯è¦–åŒ–å™¨</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Check if D3.js loaded successfully
        function checkD3() {
            if (typeof d3 === 'undefined') {
                console.error('âŒ D3.js failed to load, trying fallback...');
                
                // Try alternative CDN
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/d3@7';
                script.onload = function() {
                    console.log('âœ… D3.js fallback loaded successfully');
                    if (typeof d3 !== 'undefined') {
                        initWhenReady();
                    } else {
                        showD3Error();
                    }
                };
                script.onerror = function() {
                    console.error('âŒ D3.js fallback also failed to load');
                    showD3Error();
                };
                document.head.appendChild(script);
                return false;
            }
            console.log('âœ… D3.js loaded successfully');
            return true;
        }
        
        function showD3Error() {
            document.body.innerHTML = `
                <div style="text-align: center; padding: 50px; color: #dc3545;">
                    <h2>âŒ D3.js åº«è¼‰å…¥å¤±æ•—</h2>
                    <p>è«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–å˜—è©¦ä»¥ä¸‹è§£æ±ºæ–¹æ¡ˆï¼š</p>
                    <ul style="text-align: left; max-width: 500px; margin: 0 auto;">
                        <li>ç¢ºä¿ç¶²è·¯é€£æ¥æ­£å¸¸</li>
                        <li>æª¢æŸ¥é˜²ç«ç‰†æˆ–ä»£ç†è¨­ç½®</li>
                        <li>å˜—è©¦é‡æ–°æ•´ç†é é¢</li>
                        <li>è¯ç¹«ç³»çµ±ç®¡ç†å“¡</li>
                    </ul>
                </div>
            `;
        }
        
        function initWhenReady() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', startApp);
            } else {
                startApp();
            }
        }
        
        function startApp() {
            console.log('ğŸš€ Full viewer - DOM loaded, initializing visualizer...');
            
            try {
                const visualizer = new KnowledgeGraphVisualizer('graph-container');
                console.log('âœ… Full viewer visualizer initialization completed');
            } catch (error) {
                console.error('âŒ Full viewer initialization failed:', error);
                console.error('Error details:', error.stack);
            }
        }
    </script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .controls {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px;
        }
        
        .control-group label {
            font-weight: bold;
            color: #495057;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .stats {
            background: #e9ecef;
            padding: 10px 15px;
            font-size: 14px;
            color: #6c757d;
        }
        
        #graph-container {
            position: relative;
            width: 100%;
            height: 700px;
            overflow: hidden;
        }
        
        #search-box {
            width: 200px;
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .node {
            cursor: pointer;
            stroke: #333;
            stroke-width: 1.5px;
        }
        
        .node.highlighted {
            stroke: #ff6b6b;
            stroke-width: 3px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
        }
        
        .link.highlighted {
            stroke: #ff6b6b;
            stroke-width: 2px;
            stroke-opacity: 1;
        }
        
        .node-label {
            font-size: 10px;
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            fill: #333;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid #ccc;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>çŸ¥è­˜åœ–è­œå¯è¦–åŒ–å™¨</h1>
            <p id="file-info">è¼‰å…¥ä¸­...</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="search-box">æœå°‹ç¯€é»ï¼š</label>
                <input type="text" id="search-box" placeholder="è¼¸å…¥å¯¦é«”åç¨±...">
            </div>
            
            <div class="control-group">
                <label for="zoom-slider">ç¸®æ”¾ï¼š</label>
                <input type="range" id="zoom-slider" min="0.1" max="3" step="0.1" value="1">
                <span id="zoom-value">1.0x</span>
            </div>
            
            <div class="control-group">
                <button id="reset-btn">é‡ç½®è¦–åœ–</button>
                <button id="pause-btn">æš«åœ/ç¹¼çºŒ</button>
            </div>
        </div>
        
        <div class="stats">
            <span id="stats-text">è¼‰å…¥ä¸­...</span>
        </div>
        
        <div id="graph-container">
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff7f0e;"></div>
                    <span>äººç‰©</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ca02c;"></div>
                    <span>åœ°é»</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #d62728;"></div>
                    <span>äº‹ä»¶/æ¦‚å¿µ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9467bd;"></div>
                    <span>æ–‡å­¸ä½œå“</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #1f77b4;"></div>
                    <span>å…¶ä»–</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main visualization class for knowledge graph
        class KnowledgeGraphVisualizer {
            constructor(containerId) {
                this.containerId = containerId;
                this.container = d3.select(`#${containerId}`);
                this.width = 1200;
                this.height = 700;
                this.isPaused = false;
                
                // Initialize the visualization
                this.initSVG();
                this.initTooltip();
                this.setupEventListeners();
                
                // Load and render the data
                this.loadData();
            }
            
            // Initialize SVG canvas and zoom behavior
            initSVG() {
                this.svg = this.container.append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height);
                
                // Create zoom behavior
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                        // Update zoom display
                        document.getElementById('zoom-value').textContent = 
                            event.transform.k.toFixed(1) + 'x';
                        document.getElementById('zoom-slider').value = event.transform.k;
                    });
                
                this.svg.call(this.zoom);
                
                // Create main group for all graph elements
                this.g = this.svg.append('g');
            }
            
            // Initialize tooltip for hover information
            initTooltip() {
                this.tooltip = d3.select('body').append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0);
            }
            
            // Set up event listeners for controls
            setupEventListeners() {
                // Search functionality
                d3.select('#search-box').on('input', (event) => {
                    this.searchNodes(event.target.value);
                });
                
                // Zoom slider control
                d3.select('#zoom-slider').on('input', (event) => {
                    const scale = parseFloat(event.target.value);
                    this.svg.transition().duration(300).call(
                        this.zoom.transform,
                        d3.zoomIdentity.scale(scale)
                    );
                });
                
                // Reset view button
                d3.select('#reset-btn').on('click', () => {
                    this.resetView();
                });
                
                // Pause/Resume button
                d3.select('#pause-btn').on('click', () => {
                    this.toggleSimulation();
                });
            }
            
            // Load data from API
            async loadData() {
                console.log('ğŸ”„ Full viewer - Starting data loading...');
                document.getElementById('stats-text').textContent = 'æ­£åœ¨è¼‰å…¥æ•¸æ“š...';
                
                try {
                    // Check if specific file is requested via URL parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    const selectedFile = urlParams.get('file');
                    
                    console.log(`ğŸ“ Requested file: ${selectedFile || 'default file'}`);
                    
                    // Construct API URL with file parameter if specified
                    const apiUrl = selectedFile ? `/api/graph-data?file=${encodeURIComponent(selectedFile)}` : '/api/graph-data';
                    console.log(`ğŸ“¡ API URL: ${apiUrl}`);
                    
                    console.log('ğŸ“ Sending API request...');
                    // Load the JSON data from API
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    console.log('âœ… API response successful, parsing JSON...');
                    const data = await response.json();
                    console.log('ğŸ“Š Received data:', {
                        entities: data.entities?.length || 0,
                        relationships: data.relationships?.length || 0,
                        fixes: data.fixes_applied || 0
                    });
                    
                    // Check if this is an empty graph response
                    if (data.empty_graph) {
                        // Handle empty graph case
                        document.getElementById('file-info').textContent = `äº’å‹•å¼çŸ¥è­˜åœ–è­œ (å®Œæ•´ç‰ˆ) - æš«ç„¡è³‡æ–™`;
                        this.showNotification('æ²’æœ‰å¯ç”¨çš„åœ–è­œè³‡æ–™ã€‚è«‹ä¸Šå‚³ JSON æ ¼å¼çš„åœ–è­œæª”æ¡ˆä¾†é–‹å§‹è¦–è¦ºåŒ–ã€‚', 'info');
                        
                        // Show empty state message in the visualization area
                        this.g.selectAll('*').remove();
                        
                        this.g.append('text')
                            .attr('x', this.width / 2)
                            .attr('y', this.height / 2)
                            .attr('text-anchor', 'middle')
                            .attr('font-family', 'Arial, sans-serif')
                            .attr('font-size', '24px')
                            .attr('fill', '#666')
                            .text('æš«ç„¡åœ–è­œè³‡æ–™');
                        
                        this.g.append('text')
                            .attr('x', this.width / 2)
                            .attr('y', this.height / 2 + 40)
                            .attr('text-anchor', 'middle')
                            .attr('font-family', 'Arial, sans-serif')
                            .attr('font-size', '16px')
                            .attr('fill', '#999')
                            .text('è«‹ä¸Šå‚³ JSON æ ¼å¼çš„åœ–è­œæª”æ¡ˆä¾†é–‹å§‹è¦–è¦ºåŒ–');
                        
                        // Update stats for empty graph
                        this.updateStatsForEmptyGraph();
                        
                        console.log('âœ… Empty graph state displayed');
                        return;
                    }
                    
                    // Update file info display
                    const sourceFile = data.source_file || 'é è¨­æª”æ¡ˆ';
                    document.getElementById('file-info').textContent = `åŸºæ–¼ ${sourceFile} çš„äº’å‹•å¼çŸ¥è­˜åœ–è­œ (å®Œæ•´ç‰ˆ)`;
                    console.log(`ğŸ“ Updated file info display: ${sourceFile}`);
                    
                    // Check if server applied fixes
                    if (data.fixes_applied > 0) {
                        console.log(`âœ… Server automatically fixed ${data.fixes_applied} missing entities`);
                        console.log('Fixed entities:', data.missing_entities_found);
                        
                        // Show notification to user
                        this.showNotification(`å·²è‡ªå‹•ä¿®å¾© ${data.fixes_applied} å€‹æ•¸æ“šä¸ä¸€è‡´å•é¡Œ`, 'success');
                    }
                    
                    console.log('ğŸ”§ Starting data processing...');
                    this.processData(data);
                    
                    console.log('ğŸ¨ Starting visualization creation...');
                    this.createVisualization();
                    
                    console.log('âœ… Full viewer loading completed!');
                    
                } catch (error) {
                    console.error('âŒ Full viewer loading error:', error);
                    console.error('Error details:', error.stack);
                    this.showError(`ç„¡æ³•è¼‰å…¥æ•¸æ“šï¼š${error.message}`);
                }
            }
            
            // Process raw JSON data into D3-compatible format
            processData(rawData) {
                console.log('ğŸ”§ Full viewer - Starting raw data processing...');
                console.log('ğŸ“Š Raw data structure:', {
                    hasEntities: !!rawData.entities,
                    hasRelationships: !!rawData.relationships,
                    entitiesType: typeof rawData.entities,
                    relationshipsType: typeof rawData.relationships,
                    entitiesLength: rawData.entities?.length,
                    relationshipsLength: rawData.relationships?.length
                });
                
                this.rawData = rawData;
                
                if (!rawData.entities || !Array.isArray(rawData.entities)) {
                    console.error('âŒ Invalid entities data:', rawData.entities);
                    throw new Error('Entity data format error');
                }
                
                if (!rawData.relationships || !Array.isArray(rawData.relationships)) {
                    console.error('âŒ Invalid relationships data:', rawData.relationships);
                    throw new Error('Relationship data format error');
                }
                
                console.log('âœ… æ•¸æ“šæ ¼å¼é©—è­‰é€šé');
                
                // Create nodes from entities
                console.log('ğŸ”¨ å‰µå»ºç¯€é»æ•¸æ“š...');
                this.nodes = rawData.entities.map((entity, index) => {
                    const node = {
                        id: entity,
                        name: entity,
                        type: this.classifyEntity(entity),
                        index: index
                    };
                    
                    if (index < 5) { // åªè¨˜éŒ„å‰5å€‹ç¯€é»çš„è©³ç´°ä¿¡æ¯
                        console.log(`  ç¯€é» ${index + 1}: ${entity} (é¡å‹: ${node.type})`);
                    }
                    
                    return node;
                });
                
                console.log(`âœ… æˆåŠŸå‰µå»º ${this.nodes.length} å€‹ç¯€é»`);
                
                // Create links from relationships
                console.log('ğŸ”— å‰µå»ºé—œä¿‚æ•¸æ“š...');
                let validLinks = 0;
                let invalidLinks = 0;
                
                this.links = rawData.relationships.map((rel, index) => {
                    const parts = rel.split(' - ');
                    if (parts.length >= 3) {
                        const source = parts[0];
                        const target = parts[2];
                        const relationship = parts[1];
                        
                        const link = {
                            source: source,
                            target: target,
                            relationship: relationship,
                            id: index
                        };
                        
                        if (index < 5) { // åªè¨˜éŒ„å‰5å€‹é—œä¿‚çš„è©³ç´°ä¿¡æ¯
                            console.log(`  é—œä¿‚ ${index + 1}: ${link.source} -> ${link.target} (${link.relationship})`);
                        }
                        
                        validLinks++;
                        return link;
                    } else {
                        console.warn(`âš ï¸ é—œä¿‚æ ¼å¼éŒ¯èª¤: ${rel}`);
                        invalidLinks++;
                        return null;
                    }
                }).filter(link => link !== null);
                
                console.log(`âœ… æˆåŠŸå‰µå»º ${this.links.length} å€‹æœ‰æ•ˆé—œä¿‚ (ç„¡æ•ˆ: ${invalidLinks})`);
                console.log(`ğŸ”§ æ•¸æ“šè™•ç†å®Œæˆ: ${this.nodes.length} ç¯€é», ${this.links.length} é—œä¿‚`);
                
                console.log('ğŸ“Š æ›´æ–°çµ±è¨ˆè³‡è¨Š...');
                // Update statistics
                this.updateStats();
            }
            
            // Classify entities into different types for color coding
            classifyEntity(entity) {
                // Character names (people)
                if (entity.includes('éš±') || entity.includes('æ‘') || entity.includes('è‹±è“®') || 
                    entity.includes('å°æ°') || entity.includes('å°è‚…') || entity.includes('æ½˜å®‰') ||
                    entity.includes('è¥¿å­') || entity.includes('æ›¹é›ªèŠ¹')) {
                    return 'person';
                }
                
                // Locations
                if (entity.includes('å»Ÿ') || entity.includes('å±±') || entity.includes('å³°') || 
                    entity.includes('å··') || entity.includes('é–€') || entity.includes('è¡—') ||
                    entity.includes('äº¬åŸ') || entity.includes('æ•…é„‰') || entity.includes('å®¶é„‰')) {
                    return 'location';
                }
                
                // Literary works
                if (entity.includes('ã€Š') && entity.includes('ã€‹')) {
                    return 'literature';
                }
                
                // Events and concepts
                if (entity.includes('å¤¢') || entity.includes('æƒ…') || entity.includes('è©©') ||
                    entity.includes('åŠŸå') || entity.includes('å¯Œè²´') || entity.includes('æ„›')) {
                    return 'concept';
                }
                
                return 'other';
            }
            
            // Create the main visualization
            createVisualization() {
                console.log('ğŸ¨ å®Œæ•´ç‰ˆ - é–‹å§‹å‰µå»ºå¯è¦–åŒ–...');
                console.log(`ğŸ“ ç•«å¸ƒå°ºå¯¸: ${this.width} x ${this.height}`);
                
                if (!this.nodes || this.nodes.length === 0) {
                    console.error('âŒ ç¯€é»æ•¸æ“šç‚ºç©ºï¼Œç„¡æ³•å‰µå»ºå¯è¦–åŒ–');
                    throw new Error('ç¯€é»æ•¸æ“šç‚ºç©º');
                }
                
                if (!this.links || this.links.length === 0) {
                    console.error('âŒ é—œä¿‚æ•¸æ“šç‚ºç©ºï¼Œç„¡æ³•å‰µå»ºå¯è¦–åŒ–');
                    throw new Error('é—œä¿‚æ•¸æ“šç‚ºç©º');
                }
                
                console.log(`ğŸ”§ æº–å‚™å‰µå»ºåŠ›å°å‘åœ–: ${this.nodes.length} ç¯€é», ${this.links.length} é—œä¿‚`);
                
                try {
                    // Clear any existing visualization
                    this.g.selectAll('*').remove();
                    console.log('ğŸ§¹ æ¸…é™¤èˆŠçš„å¯è¦–åŒ–å…ƒç´ ');
                    
                    // Initialize force simulation
                    console.log('âš¡ åˆå§‹åŒ–åŠ›å°å‘æ¨¡æ“¬...');
                    this.simulation = d3.forceSimulation(this.nodes)
                        .force('link', d3.forceLink(this.links)
                            .id(d => d.id)
                            .distance(80)
                            .strength(0.3)
                        )
                        .force('charge', d3.forceManyBody()
                            .strength(-200)
                            .distanceMax(300)
                        )
                        .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                        .force('collision', d3.forceCollide().radius(25));
                    
                    console.log('âœ… åŠ›å°å‘æ¨¡æ“¬åˆå§‹åŒ–å®Œæˆ');
                    
                    // Create links
                    console.log('ğŸ”— å‰µå»ºé—œä¿‚å¯è¦–åŒ–å…ƒç´ ...');
                    this.linkElements = this.g.append('g')
                        .attr('class', 'links')
                        .selectAll('line')
                        .data(this.links)
                        .enter().append('line')
                        .attr('class', 'link')
                        .style('stroke-width', 1);
                    
                    console.log(`âœ… æˆåŠŸå‰µå»º ${this.linkElements.size()} å€‹é—œä¿‚ç·šæ¢`);
                    
                    // Create nodes
                    console.log('â­• å‰µå»ºç¯€é»å¯è¦–åŒ–å…ƒç´ ...');
                    this.nodeElements = this.g.append('g')
                        .attr('class', 'nodes')
                        .selectAll('circle')
                        .data(this.nodes)
                        .enter().append('circle')
                        .attr('class', 'node')
                        .attr('r', d => Math.max(8, Math.min(15, d.name.length * 2)))
                        .style('fill', d => this.getNodeColor(d.type))
                        .call(this.createDragBehavior());
                    
                    console.log(`âœ… æˆåŠŸå‰µå»º ${this.nodeElements.size()} å€‹ç¯€é»åœ“åœˆ`);
                    
                    // Add labels
                    console.log('ğŸ·ï¸ å‰µå»ºæ¨™ç±¤å…ƒç´ ...');
                    this.labelElements = this.g.append('g')
                        .attr('class', 'labels')
                        .selectAll('text')
                        .data(this.nodes)
                        .enter().append('text')
                        .attr('class', 'node-label')
                        .text(d => d.name.length > 6 ? d.name.substring(0, 6) + '...' : d.name)
                        .style('font-size', '10px');
                    
                    console.log(`âœ… æˆåŠŸå‰µå»º ${this.labelElements.size()} å€‹æ¨™ç±¤`);
                    
                    // Add event listeners
                    console.log('ğŸ‘† æ·»åŠ äº‹ä»¶ç›£è½å™¨...');
                    this.addEventListeners();
                    console.log('âœ… äº‹ä»¶ç›£è½å™¨æ·»åŠ å®Œæˆ');
                    
                    // Start simulation
                    console.log('ğŸ”„ å•Ÿå‹•å‹•ç•«æ¨¡æ“¬...');
                    let tickCount = 0;
                    this.simulation.on('tick', () => {
                        tickCount++;
                        this.updatePositions();
                        
                        // åªåœ¨å‰å¹¾æ¬¡ tick æ™‚è¨˜éŒ„
                        if (tickCount <= 5) {
                            console.log(`ğŸ”„ Tick ${tickCount}: ä½ç½®æ›´æ–°å®Œæˆ`);
                        }
                    });
                    
                    console.log('âœ… å®Œæ•´ç‰ˆå¯è¦–åŒ–å‰µå»ºå®Œæˆï¼');
                    
                } catch (error) {
                    console.error('âŒ å‰µå»ºå¯è¦–åŒ–æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    throw error;
                }
            }
            
            // Get color for different node types
            getNodeColor(type) {
                const colors = {
                    'person': '#ff7f0e',
                    'location': '#2ca02c', 
                    'concept': '#d62728',
                    'literature': '#9467bd',
                    'other': '#1f77b4'
                };
                return colors[type] || colors.other;
            }
            
            // Create drag behavior for nodes
            createDragBehavior() {
                return d3.drag()
                    .on('start', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on('drag', (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on('end', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0);
                        // Keep node fixed after dragging (double-click to unfix)
                    });
            }
            
            // Add event listeners for interactions
            addEventListeners() {
                try {
                    console.log('ğŸ‘† è¨­å®šç¯€é»äº‹ä»¶ç›£è½å™¨...');
                    
                    if (!this.nodeElements || this.nodeElements.empty()) {
                        console.error('âŒ ç¯€é»å…ƒç´ ç‚ºç©ºï¼Œç„¡æ³•æ·»åŠ äº‹ä»¶ç›£è½å™¨');
                        return;
                    }
                    
                    // Node hover events
                    this.nodeElements
                        .on('mouseover', (event, d) => {
                            console.log(`ğŸ–±ï¸ é¼ æ¨™æ‡¸åœç¯€é»: ${d.name}`);
                            this.showTooltip(event, d);
                            this.highlightConnections(d);
                        })
                        .on('mouseout', (event, d) => {
                            console.log(`ğŸ–±ï¸ é¼ æ¨™é›¢é–‹ç¯€é»: ${d.name}`);
                            this.hideTooltip();
                            this.clearHighlights();
                        })
                        .on('dblclick', (event, d) => {
                            console.log(`ğŸ–±ï¸ é›™æ“Šç¯€é»å–æ¶ˆå›ºå®š: ${d.name}`);
                            // Double-click to unpin node
                            d.fx = null;
                            d.fy = null;
                        });
                        
                    console.log(`âœ… å·²ç‚º ${this.nodeElements.size()} å€‹ç¯€é»æ·»åŠ äº‹ä»¶ç›£è½å™¨`);
                    
                } catch (error) {
                    console.error('âŒ æ·»åŠ äº‹ä»¶ç›£è½å™¨æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
            
            // Update positions during simulation
            updatePositions() {
                if (this.isPaused) return;
                
                this.linkElements
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                this.nodeElements
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                this.labelElements
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 20);
            }
            
            // Show tooltip with node information
            showTooltip(event, d) {
                const connections = this.getNodeConnections(d);
                const content = `
                    <strong>${d.name}</strong><br/>
                    é¡å‹: ${this.getTypeLabel(d.type)}<br/>
                    é€£æ¥æ•¸: ${connections.length}
                `;
                
                this.tooltip
                    .style('opacity', 1)
                    .html(content)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            }
            
            // Hide tooltip
            hideTooltip() {
                this.tooltip.style('opacity', 0);
            }
            
            // Get Chinese label for entity type
            getTypeLabel(type) {
                const labels = {
                    'person': 'äººç‰©',
                    'location': 'åœ°é»',
                    'concept': 'äº‹ä»¶/æ¦‚å¿µ', 
                    'literature': 'æ–‡å­¸ä½œå“',
                    'other': 'å…¶ä»–'
                };
                return labels[type] || 'æœªçŸ¥';
            }
            
            // Get all connections for a node
            getNodeConnections(node) {
                return this.links.filter(link => 
                    link.source.id === node.id || link.target.id === node.id
                );
            }
            
            // Highlight connections for selected node
            highlightConnections(selectedNode) {
                const connections = this.getNodeConnections(selectedNode);
                const connectedNodeIds = new Set();
                
                connections.forEach(link => {
                    connectedNodeIds.add(link.source.id);
                    connectedNodeIds.add(link.target.id);
                });
                
                // Highlight connected nodes
                this.nodeElements
                    .classed('highlighted', d => connectedNodeIds.has(d.id));
                
                // Highlight connected links
                this.linkElements
                    .classed('highlighted', d => 
                        d.source.id === selectedNode.id || d.target.id === selectedNode.id
                    );
            }
            
            // Clear all highlights
            clearHighlights() {
                this.nodeElements.classed('highlighted', false);
                this.linkElements.classed('highlighted', false);
            }
            
            // Search nodes by name
            searchNodes(searchTerm) {
                if (!searchTerm.trim()) {
                    this.clearHighlights();
                    return;
                }
                
                const term = searchTerm.toLowerCase();
                this.nodeElements
                    .classed('highlighted', d => 
                        d.name.toLowerCase().includes(term)
                    );
            }
            
            // Reset view to initial state
            resetView() {
                this.svg.transition().duration(750).call(
                    this.zoom.transform,
                    d3.zoomIdentity
                );
                
                this.clearHighlights();
                document.getElementById('search-box').value = '';
                
                // Restart simulation
                this.simulation.alpha(0.3).restart();
            }
            
            // Toggle simulation pause/resume
            toggleSimulation() {
                this.isPaused = !this.isPaused;
                const button = document.getElementById('pause-btn');
                button.textContent = this.isPaused ? 'ç¹¼çºŒ' : 'æš«åœ';
                
                if (!this.isPaused) {
                    this.simulation.alpha(0.1).restart();
                }
            }
            
            // Update statistics display
            updateStats() {
                try {
                    const entityCounts = this.getEntityTypeCounts();
                    const statsText = `å¯¦é«”æ•¸é‡: ${this.nodes.length} | é—œä¿‚æ•¸é‡: ${this.links.length} | äººç‰©: ${entityCounts.person} | åœ°é»: ${entityCounts.location} | æ–‡å­¸ä½œå“: ${entityCounts.literature}`;
                    document.getElementById('stats-text').textContent = statsText;
                    console.log('âœ… çµ±è¨ˆè³‡è¨Šå·²æ›´æ–°:', statsText);
                } catch (error) {
                    console.error('âŒ æ›´æ–°çµ±è¨ˆè³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    document.getElementById('stats-text').textContent = `å¯¦é«”æ•¸é‡: ${this.nodes.length} | é—œä¿‚æ•¸é‡: ${this.links.length}`;
                }
            }
            
            // Update statistics display for empty graph
            updateStatsForEmptyGraph() {
                try {
                    const statsText = `å¯¦é«”æ•¸é‡: 0 | é—œä¿‚æ•¸é‡: 0 | äººç‰©: 0 | åœ°é»: 0 | æ–‡å­¸ä½œå“: 0`;
                    document.getElementById('stats-text').textContent = statsText;
                    console.log('âœ… ç©ºåœ–è­œçµ±è¨ˆè³‡è¨Šå·²æ›´æ–°:', statsText);
                } catch (error) {
                    console.error('âŒ æ›´æ–°ç©ºåœ–è­œçµ±è¨ˆè³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    document.getElementById('stats-text').textContent = `å¯¦é«”æ•¸é‡: 0 | é—œä¿‚æ•¸é‡: 0`;
                }
            }
            
            // Get counts of different entity types
            getEntityTypeCounts() {
                const counts = {
                    person: 0,
                    location: 0,
                    literature: 0,
                    concept: 0,
                    other: 0
                };
                
                this.nodes.forEach(node => {
                    counts[node.type] = (counts[node.type] || 0) + 1;
                });
                
                return counts;
            }
            
            // Show error message
            showError(message) {
                this.container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '50px')
                    .style('color', '#dc3545')
                    .text(message);
            }
            
            // Show notification message
            showNotification(message, type = 'info') {
                const colors = {
                    'success': '#28a745',
                    'warning': '#ffc107',
                    'error': '#dc3545',
                    'info': '#17a2b8'
                };
                
                const notification = d3.select('body')
                    .append('div')
                    .style('position', 'fixed')
                    .style('top', '20px')
                    .style('right', '20px')
                    .style('background', colors[type] || colors.info)
                    .style('color', 'white')
                    .style('padding', '10px 15px')
                    .style('border-radius', '5px')
                    .style('box-shadow', '0 2px 10px rgba(0,0,0,0.1)')
                    .style('z-index', '1000')
                    .style('opacity', '0')
                    .text(message);
                
                // Fade in
                notification.transition()
                    .duration(300)
                    .style('opacity', '1');
                
                // Auto remove after 3 seconds
                setTimeout(() => {
                    notification.transition()
                        .duration(300)
                        .style('opacity', '0')
                        .remove();
                }, 3000);
            }
        }
        
        // Initialize visualization when page loads
        window.onload = function() {
            console.log('ğŸ” Checking D3.js loading status...');
            if (checkD3()) {
                initWhenReady();
            }
        };
    </script>
</body>
</html> 